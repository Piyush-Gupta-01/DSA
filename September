//<----------------------------------------------DAY-1-03/09/24------------------------------------------------------------>
#53.MAXIMUM SUBARRAY LEETCODE
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

    //       <--------------USING KADANE'S ALGO----------------->

    int n=nums.size();
    int sum=0;
    int max=INT_MIN;
    for(int i=0;i<n;i++){
        sum+=nums[i];
        if(sum>max) max=sum;
        if(sum<0) sum=0;
    }
    return max;
    }
};

//<------------------------------------------------DAY-2-04/09/24----------------------------------------------------------->
#11.Container with maximum water LEETCODE
class Solution {
public:
    int maxArea(vector<int>& height) {
//    <--------------USING TWO POINTER-------------->
   int i=0;
   int res=0;
   int j=height.size()-1;
   while(i<j){
   int area= (j-i)*min(height[i],height[j]);
   res=max(res,area);
   if(height[i]<height[j]) i++;
   else j--;
   }
   return res;
    }
};

//<-------------------------------------------------DAY-3-05/09/24--------------------------------------------------------->
#202.HAPPY NUMBER LEETCODE
class Solution {
public:
    bool isHappy(int n) {

     //***BOTH APPROACHES HAVE SAME TIME AND SPACE COMPLEXITY***

        // <------------------USING RECURSION------------------->
        // <---THIS IS OPTIMISED O(LOGN) AND O(1) TIME AND SPACE COMPLEXITY--->
        // if(n==4) return false;
        // if(n==1) return true;
        // int nextN=0;
        // int rem=0;
        // while(n>0){
        //      rem=n%10;
        //      nextN+=rem*rem;
        //     n/=10;
        // }
        // return isHappy(nextN);


    //    //<-----------FLOYD'S CYCLE DETECTION ALGO---------->
    //    //<<---ALSO CALLED TURTOISE OR HARE ALGO--->>

    //    int slow=n;
    //    int fast=findNext(n);
    //    while(fast!=1&& slow!=fast){
    //     slow=findNext(slow);
    //     fast=findNext(findNext(fast));
    //    }
    //    if(fast==1) return true;

    //    return false;
    // }
    // int findNext(int n){
    //     int rem=0;
    //     int nextN=0;
    //     while(n>0){
    //   rem=n%10;
    //   nextN+=rem*rem;
    //   n/=10;
    //     }
    //     return nextN;
    }
};

//<--------------------------------------------------DAY-4 06/09/24-------------------------------------------------------->





