//<----------------------------------------------DAY-1-03/09/24------------------------------------------------------------>
#53.MAXIMUM SUBARRAY LEETCODE
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

    //       <--------------USING KADANE'S ALGO----------------->

    int n=nums.size();
    int sum=0;
    int max=INT_MIN;
    for(int i=0;i<n;i++){
        sum+=nums[i];
        if(sum>max) max=sum;
        if(sum<0) sum=0;
    }
    return max;
    }
};

//<------------------------------------------------DAY-2-04/09/24----------------------------------------------------------->
#11.Container with maximum water LEETCODE
class Solution {
public:
    int maxArea(vector<int>& height) {
//    <--------------USING TWO POINTER-------------->
   int i=0;
   int res=0;
   int j=height.size()-1;
   while(i<j){
   int area= (j-i)*min(height[i],height[j]);
   res=max(res,area);
   if(height[i]<height[j]) i++;
   else j--;
   }
   return res;
    }
};

//<-------------------------------------------------DAY-3-05/09/24--------------------------------------------------------->
#202.HAPPY NUMBER LEETCODE
class Solution {
public:
    bool isHappy(int n) {

     //***BOTH APPROACHES HAVE SAME TIME AND SPACE COMPLEXITY***

        // <------------------USING RECURSION------------------->
        // <---THIS IS OPTIMISED O(LOGN) AND O(1) TIME AND SPACE COMPLEXITY--->
        // if(n==4) return false;
        // if(n==1) return true;
        // int nextN=0;
        // int rem=0;
        // while(n>0){
        //      rem=n%10;
        //      nextN+=rem*rem;
        //     n/=10;
        // }
        // return isHappy(nextN);


    //    //<-----------FLOYD'S CYCLE DETECTION ALGO---------->
    //    //<<---ALSO CALLED TURTOISE OR HARE ALGO--->>

    //    int slow=n;
    //    int fast=findNext(n);
    //    while(fast!=1&& slow!=fast){
    //     slow=findNext(slow);
    //     fast=findNext(findNext(fast));
    //    }
    //    if(fast==1) return true;

    //    return false;
    // }
    // int findNext(int n){
    //     int rem=0;
    //     int nextN=0;
    //     while(n>0){
    //   rem=n%10;
    //   nextN+=rem*rem;
    //   n/=10;
    //     }
    //     return nextN;
    }
};

//<--------------------------------------------------DAY-4 06/09/24-------------------------------------------------------->
#1877.Minimize Maximum Pair Sum in array LEETCODE
class Solution {
public:
    int minPairSum(vector<int>& nums) {
        
        //<-----------------------USING SORTING------------------>

        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size()-1;
        int maximum=-1;
        while(i<j){
          maximum=max(maximum,nums[i]+nums[j]);
            i++;
            j--;
        }
        return maximum;
    }
};

//<-----------------------------------------------------DAY-4-O7/09/24----------------------------------------------------->
496.Next Greater Element LEETCODE
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {

        //<------------------BRUTE FORCE ------------------->
    //     vector<int>vc;
    //    for(int i=0;i<nums1.size();i++){
    //     int k=-1;
    //     for(int j=0;j<nums2.size();j++){
    //         if(nums1[i]==nums2[j]){
    //             k=j;
    //             break;
    //         }
    //     }
    //     bool found=false;
    //     for(int j=k+1;j<nums2.size();j++){
    //         if(nums2[j]>nums2[k]){
    //          vc.push_back(nums2[j]);
    //          found=true;
    //          break;
    //         }
    //     }
    //     if(!found){
    //     vc.push_back(-1);
    //     }
    //    }
    //    return vc;

    //<----------------------USING STACK-------------------------->

    unordered_map<int,int>mp;
    stack<int>st;
    vector<int>vc;
    for(int i=nums2.size()-1;i>=0;i--){
        int currElement=nums2[i];
        while(!st.empty()&&st.top()<=currElement){
            st.pop();
        }
        int res=(st.empty())?-1:st.top();
      mp.insert({currElement,res});
      st.push(currElement);
    }
    for(auto i:nums1){
  vc.push_back(mp[i]);
    }
    return vc;
    }
};

503.Next Greater Element-2 LEETCODE
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& num) {
        
        //<------------------USING STACK--------------------->

    stack<int>st;
    int n=num.size();
    vector<int>vc(n,-1);
    for(int i=2*n-1;i>=0;i--){
       
        while(!st.empty()&&st.top()<=num[i%n]){
            st.pop();
        }
        if(i<n){
       vc[i]=(st.empty())?-1:st.top();
        }
      st.push(num[i%n]);
    }
   
    return vc;
    }
};

//<---------------------------------------------------DAY-5 08/09/24------------------------------------------------------>
238. Product of Array Except Self LEETCODE
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        //<-------------USING LEFT AND RIGHT ARRAY---------------->
        vector<int>left(nums.size(),1);
        vector<int>right(nums.size(),1);

        for(int i=1;i<nums.size();i++){
        left[i]=left[i-1]*nums[i-1];
        }

        for(int i=nums.size()-2;i>=0;i--){
            right[i]=right[i+1]*nums[i+1];
        }
        
        vector<int>res(nums.size());
        for(int i=0;i<nums.size();i++){
        res[i]=left[i]*right[i];
        }
        return res;
    }
};

